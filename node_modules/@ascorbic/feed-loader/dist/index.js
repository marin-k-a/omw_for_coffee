// src/feed-loader.ts
import FeedParser from "feedparser";

// src/schema.ts
import { z } from "astro/zod";
var NSSchema = z.record(z.string());
var ImageSchema = z.object({
  url: z.string().optional(),
  title: z.string().optional()
});
var MetaSchema = z.object({
  "#ns": z.array(NSSchema),
  "#type": z.enum(["atom", "rss", "rdf"]),
  "#version": z.string(),
  title: z.string(),
  description: z.string().nullable(),
  date: z.coerce.date().nullable(),
  pubdate: z.coerce.date().nullable(),
  link: z.string().nullable(),
  xmlurl: z.string().nullable(),
  author: z.string().nullable(),
  language: z.string().nullable(),
  image: ImageSchema.nullable(),
  favicon: z.string().nullable(),
  copyright: z.string().nullable(),
  generator: z.string().nullable(),
  categories: z.array(z.string())
});
var EnclosureSchema = z.object({
  length: z.string().optional(),
  type: z.string().optional(),
  url: z.string()
});
var ItemSchema = z.object({
  title: z.string().nullable(),
  description: z.string().nullable(),
  summary: z.string().nullable(),
  date: z.coerce.date().nullable(),
  pubdate: z.coerce.date().nullable(),
  link: z.string().nullable(),
  origlink: z.string().nullable(),
  author: z.string().nullable(),
  guid: z.string(),
  comments: z.string().nullable(),
  image: ImageSchema,
  categories: z.array(z.string()),
  enclosures: z.array(EnclosureSchema),
  meta: MetaSchema
});

// src/streams.ts
import { Readable } from "stream";
function webToNodeStream(webStream) {
  const reader = webStream.getReader();
  return new Readable({
    async read() {
      try {
        const { done, value } = await reader.read();
        if (done) {
          this.push(null);
        } else {
          this.push(Buffer.from(value));
        }
      } catch (err) {
        this.destroy(err);
      }
    }
  });
}

// src/feed-loader.ts
import {
  getConditionalHeaders,
  storeConditionalHeaders
} from "@ascorbic/loader-utils";
function feedLoader({
  url,
  requestOptions = {}
}) {
  const feedUrl = new URL(url);
  return {
    name: "feed-loader",
    load: async ({ store, logger, parseData, meta }) => {
      logger.info("Loading posts");
      const parser = new FeedParser({ feedurl: feedUrl.toString() });
      requestOptions.headers = getConditionalHeaders({
        init: requestOptions.headers,
        meta
      });
      const res = await fetch(feedUrl, requestOptions);
      if (res.status === 304) {
        logger.info(`Feed ${feedUrl} not modified, skipping`);
        return;
      }
      if (!res.ok) {
        throw new Error(`Failed to fetch feed: ${res.statusText}`);
      }
      if (!res.body) {
        throw new Error("Response body is empty");
      }
      store.clear();
      parser.on("readable", async () => {
        let item;
        while ((item = parser.read()) !== null) {
          const id = item.guid;
          if (!id) {
            logger.warn("Item does not have a guid, skipping");
            continue;
          }
          const data = await parseData({
            id,
            data: item
          });
          store.set({
            id,
            data,
            rendered: {
              html: data.description ?? ""
            }
          });
        }
      });
      const stream = webToNodeStream(res.body);
      stream.pipe(parser);
      return new Promise((resolve, reject) => {
        parser.on("end", () => {
          storeConditionalHeaders({
            headers: res.headers,
            meta
          });
          resolve();
        });
        parser.on("error", (err) => {
          reject(err);
        });
      });
    },
    schema: ItemSchema
  };
}
export {
  feedLoader
};
